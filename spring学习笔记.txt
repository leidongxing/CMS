4中关键策略
基于POJO的轻量级和最小侵入性编程；
通过依赖注入和面向接口实现松耦合；
基于切面和惯例进行声明式编程；
通过切面和模板减少样板式代码；

依赖注入  DI   将所依赖的关系自动交给目标对象   而不是对象自己去获取依赖
让相互协作的软件组件保持松散耦合

面向切面编程 AOP  把遍布应用各处的功能分离出来形成可重用的组件
保持POJO的简单性

依赖注入能将组件与其协作的其他组件解耦
AOP有助于将应用组件与跨多个组建的任务进行解耦

容器是spring的核心    容器可归为两种不同类型
bean工厂类型    org.springframework.beans.factory.beanFactory
应用上下文类型  org.springframework.context.ApplicationContext


自动化装配
组件扫描  component scanning   spring自动发现应用上下文中的bean
自动装配  autowiring       spring自动满足bean之间的依赖


Spring应用上下文默认创建的bean为单例形式
Singleton 单例    整个应用中 只创建bean的一个实例
Prototype 原型   每次注入或者通过Spring应用获取的时候 都会创建一个新的实例
Session  会话  web应用中 每个会话创建一个
Request 请求  web应用中 每个请求创建一个

属性占位符  ${...}
Spring Expression Language（SpEL）
#{T(System).out}   T()将表达式视为Java对应的类型
#{T(java.lang.Math).PI}  可以访问目标类型的静态方法和常量
#{2 * T(java.lang.Math).PI * circle.radius}
#{sgtPeppers.artist}   通过beanid 获取属性
#{systemProperties['disc.title']}  通过systemProperties对象引用系统属性
#{'Hello'}  #{false}字面值  算术 关系 逻辑运算
#{artistSelector.selectArtist()?.toUpperCase()}  如果？前的不是null  会调用toUpperCase方法
#{counter.total ==100}     #{counter.total  eq 100}  比较运算符
#{scoreboard.score  ? "winner":"Loser"}三元运算符
#{amin.email  matches   '[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.com]'}通过match运算符支持表达式中的模式匹配
#{box.songs[{T(java.lang.Math).random() }* box.size()].title}
#{'this is a test'[2]}
#{juak.box.songs.?{artist eq 'matchthing'}}
#{juak.box.songs.![title]}   投影到新的title集合中


@Component注解表明该类会作为组件类，并告知Spring要为这个类创建bean
@ComponentScan注解在Spring中启用组件扫描    主要用在被自动扫描和装配的类上
@Autowired注解用在构造器上，还能用在属性的Setter方法上
@Configuration注解表明这个类是一个配置类
@Bean注解会告诉Spring这个方法将会返回一个对象，该对象要注册为Spring应用上下文中的bean     主要用在方法上 显式声明生成的类
@Named注解来为bean设置ID  Java依赖注入规范（Java Dependency Injection）
@Inject注解 来源于Java依赖注入规范
@Profile注解应用在了类级别上   条件化创建bean方面
@ActiveProfiles激活特定的Profile
@Conditional注解定义条件化的bean
@Primary 避免自动装配Bean的歧义性  首选
@Qualifier注解  限定bean 
@PropertySource注解  声明properties 源
@Value 注解  @Value("${disc.title}") String title,



一些功能需要出现在应用程序的多个地方 但是不想在多个点明确他们
散布在应用中多处的功能被称为横切关注点  横切关注点的从概念上是与业务逻辑相分离的
但是往往会直接嵌入到应用的业务逻辑之中
把这些横切关注点与业务逻辑相分离正是面向切面编程所要解决的问题

通知(advice)
前置通知  目标方法被调用之前调用通知功能   Before
后置通知  目标方法完成之后调用通知功能   After
返回通知  目标方法成功执行之后调用通知   After-returning
异常通知  目标方法抛出异常之后调用通知   After-throwing
环绕通知  通知包裹了被通知的方法，在被通知的方法调用之前和调用之后执行自定义的行为  Around

连接点(join point)
应用执行过程中能够插入切面的一个点

切点(pointcut)
匹配通知所有要织入的一个或多个连接点

切面(Aspect)
通知和切点的结合    在何时与何处完成功能

引入(Inroduction)
向现有的类加入新的方法

织入(Weaving)
把切面应用到目标对象并创建新的代理对象的过程
目标对象的生命周期有多个点可以织入
编译期     切面在目标类编译时被织入（需要特殊的编译器）
类加载期  切面在目标类加载到JVM时被织入（需要特殊的类加载器）
运行期  切面在应用运行的某个时刻被织入（Spring AOP）

Spring只支持方法连接点，更细粒度的连接点可以利用第三方框架AspectJ来做

Spring中使用AspectJ注解
@Pointcut 声明频繁使用的切点表达式
@EnableAspectJAutoProxy 启用AspectJ自动代理
@Before
@AfterReturning
@AfterThrowing


